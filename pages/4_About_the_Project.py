import streamlit as st

st.set_page_config(page_title="Project Methodology", page_icon="üìù ", layout="wide")

st.title("üìù Project Overview")

# --- 1. THE WHY & THE WHAT ---
st.markdown("""
This project set out to achieve two primary objectives. 

1. Determine exactly how long a specific course takes to complete based on a rider's power. This required building a custom **Physics Engine** to model the real-world forces acting on the bike.

2. Identify the fastest possible way to ride that course without increasing the average power input. 
    To solve this pacing problem, the project implements a **Genetic Algorithm** to calculate the most efficient strategy.
""")

st.markdown("---")

# --- 2. FACTORS ---
st.header("‚öôÔ∏è How the Model Works")

st.markdown("""
The model breaks the route into tiny "time steps" (e.g., every 1 second). 
At each step, it calculates both the **Mechanical Forces** acting on the bike and the **Physiological State** of the rider.
""")

st.subheader("1. Key Variables")
col1, col2, col3 = st.columns(3)

with col1:
    st.info("**Total Mass ($m$)**\n\nThe combined weight of the rider and bike.")
    st.info("**Power ($P$)**\n\nWatts generated, adjusted for drivetrain efficiency ($\eta \\approx 96\%$).")

with col2:
    st.info("**Aerodynamics ($C_d A$)**\n\nDynamic: The rider 'tucks' on descents (reducing drag) and sits up on climbs.")
    st.info("**Rolling Resistance ($C_{rr}$)**\n\nFriction between the tyres and the road surface.")

with col3:
    st.info("**Gradient ($\\theta$)**\n\nThe slope of the road, calculated from the GPX elevation data.")
    st.info("**Environment**\n\nAir density ($\\rho$) changes with altitude; Wind is applied as a vector.")

st.markdown("---")

# --- 3. FORCES SECTION ---
st.subheader("2. The Forces in Detail")
st.markdown("At every second, the engine balances four primary mechanical forces to determine the Net Force.")

# Force 2.1
st.markdown("#### **2.1. Gravity Force ($F_{grav}$)**")
st.latex(r"F_{grav} = m \cdot g \cdot \sin(\theta)")
st.markdown("""
**Where:**
* $m$: Total Mass (kg)
* $g$: Gravity ($9.81 m/s^2$)
* $\\theta$: Gradient (radians)

This is the force pulling the rider backwards on a climb, or providing acceleration on a descent.
""")

# Force 2.2
st.markdown("#### **2.2. Rolling Resistance ($F_{roll}$)**")
st.latex(r"F_{roll} = C_{rr} \cdot m \cdot g \cdot \cos(\theta)")
st.markdown("""
**Where:**
* $C_{rr}$: Rolling Resistance Coefficient (e.g., 0.005)

The friction generated as the tyres deform against the road surface.
""")

# Force 2.3
st.markdown("#### **2.3. Aerodynamic Drag ($F_{drag}$)**")
st.latex(r"F_{drag} = \frac{1}{2} \cdot \rho \cdot C_d A \cdot v_{rel}^2")
st.markdown("""
**Where:**
* $\\rho$: Air density ($kg/m^3$)
* $C_d A$: Drag area ($m^2$)
* $v_{rel}$: Air speed relative to the rider

The resistance from the air. Note that it increases with the **square** of the speed ($v^2$)‚Äîdoubling the speed requires four times the force.
""")

# Force 2.4
st.markdown("#### **2.4. Propulsive Force ($F_{prop}$)**")
st.latex(r"F_{prop} = \frac{P \cdot \eta}{v}")
st.markdown("""
**Where:**
* $P$: Power (Watts)
* $\\eta$: Efficiency (~96%)
* $v$: Speed (m/s)

The forward force generated by the rider's effort.
""")

st.markdown("---")

# --- 4. CORNERING ---
st.subheader("3. Advanced Cornering Physics")
st.markdown("""
The simulation does not simply assume a straight line. It scans the GPX file ahead of the current position to detect sharp bends. 
A key metric here is the **Radius of Curvature ($r$)**, which represents the "tightness" of the turn. A small radius indicates a sharp hairpin, while a large radius indicates a sweeping bend.
""")

st.markdown("#### **The 'Look-Ahead' Scan**")
st.markdown("""
* **Detection:** The engine analyses points ahead to calculate the radius of curvature ($r$) for approaching turns.
* **Safety Limit:** It calculates the maximum safe speed for that radius based on the available tyre friction ($\mu$).
* **Braking Logic:** If the rider approaches a corner too fast, the simulation applies a "Virtual Brake" (forcing 0 Watts) to slow the bike to the safe speed *before* entering the turn.
""")

st.markdown("#### **Cornering Speed Limit Equation**")
st.latex(r"v_{max} = \sqrt{\mu \cdot g \cdot r}")
st.markdown("""
**Where:**
* $\mu$: Friction Coefficient (e.g. 0.8 for dry tarmac)
* $g$: Gravity ($9.81 m/s^2$)
* $r$: Radius of Curvature (m)

This physics constraint prevents the model from unrealistically taking hairpin corners at full speed.
""")

st.markdown("---")

# --- 5. SIMULATION LOOP ---
st.subheader("4. The Simulation Loop")
st.markdown("The computer combines all the above factors in a **Time-Stepping Integration**:")

st.write("1. **Sum the Forces:** Calculate Net Force ($F_{net}$) from propulsion and resistance.")
st.latex(r"F_{net} = F_{prop} - (F_{grav} + F_{roll} + F_{drag})")
st.markdown("This determines the total resultant force by subtracting the opposing resistance forces (drag, gravity, friction) from the rider's forward propulsive force.")

st.write("2. **Calculate Acceleration:** Apply Newton's Second Law ($F=ma$).")
st.latex(r"a = \frac{F_{net}}{m}")
st.markdown("This calculates the precise acceleration (or deceleration) of the cyclist for the next time point.")

st.write("3. **Update Speed & Distance:** Apply acceleration to the next time step.")
st.latex(r"v_{new} = v_{old} + (a \cdot \Delta t)")
st.markdown("The system uses the calculated acceleration to update the rider's velocity and position for the subsequent time interval ($t + \Delta t$).")

st.write("4. **Repeat:** This process repeats for every single second of the ride until the finish line.")
st.markdown("The simulation iterates through this cycle thousands of times, recalculating physics at every second to build a complete, high-resolution profile of the ride.")

st.markdown("---")

# --- 6. GENETIC ALGORITHM ---
st.subheader("5. Race Strategy Optimisation")
st.markdown("""
The **Strategy Optimiser** uses a **Genetic Algorithm (GA)** to find the optimal pacing plan. 
This is a search heuristic inspired by Charles Darwin's theory of natural selection.
""")

st.markdown("#### **Step 1: Population (The Gene Pool)**")
st.markdown("The algorithm starts by creating a random population of 'riders'. Each rider has a unique DNA‚Äîa sequence of power outputs for every segment of the course.")
st.markdown("For example, one rider's DNA might dictate attacking steep gradients aggressively while recovering on flats, while another rider's DNA might attempt a steady, conservative effort throughout. This variety creates a diverse pool of strategies to test.")
st.write("")

st.info("""
**Heuristic Seeding:** To prevent the algorithm from starting completely blind, the initial population is 'seeded' with logical strategies (e.g. "Push Hard on Climbs"). This helps the algorithm converge faster.
""")

st.markdown("#### **Step 2: Selection (Survival of the Fittest)**")
st.markdown("Every rider races the course virtually. The finish times are measured, and the fastest riders are selected as 'parents', while the slow strategies are discarded.")
st.write("")

st.markdown("#### **Step 3: Crossover (Breeding)**")
st.markdown("The winning parents combine their strategies to create children. A child might take the *'Climbing Strategy'* from Parent A and the *'Descending Strategy'* from Parent B.")
st.write("")

st.markdown("#### **Step 4: Mutation (Random Variance)**")
st.markdown("To prevent stagnation, random mutations are introduced. A child might randomly decide to push 10% harder on a specific segment. If this works, it spreads to future generations.")
st.write("")

st.markdown("#### **Step 5: Elitism (Protecting the Best)**")
st.markdown("In every generation, a percentage of the fastest riders are guaranteed to survive unchanged. This ensures the best-known solution is never lost.")

st.markdown("#### **Step 6: Iteration**")
st.markdown("The algorithm repeats this cycle for the number of **Generations** set by the user, getting faster and smarter each time.")

st.warning("""
**‚ö†Ô∏è Note on Computational Cost**
* **Accuracy vs. Speed:** Increasing the Population Size and Number of Generations improves accuracy but increases processing time.
* **Demo Mode:** To ensure this web demonstration runs smoothly, parameters are currently limited to **Generations: 10** and **Population: 10**.
""")

st.markdown("---")

# --- 7. PHYSIOLOGY SECTION ---
st.subheader("6. The Physiology Engine (Skiba $W'$ Model)")
st.markdown("""
Real riders cannot sprint forever. To model fatigue, the system implements the **Skiba $W'$ Balance Model**, a widely cited framework in sports science for quantifying anaerobic work capacity.
""")

st.markdown("#### **The 'Battery' Analogy**")
st.markdown("""
Energy is conceptualised as a battery ($W'$ in Joules) that operates above the rider's Critical Power ($CP$).
* **Burning Matches:** When riding **above** Threshold ($CP$), the battery drains. The harder the effort, the faster the depletion.
* **Recharging:** When riding **below** Threshold, the battery recovers. Following Skiba's model, this recovery is **exponential**: the further the power drops below the threshold (e.g., coasting vs. soft pedaling), the significantly faster the recovery occurs.
* **The 'Bonk':** If the battery hits 0%, the rider is considered exhausted. The simulation forces the power down to a recovery intensity until the balance is restored.
""")

st.markdown("#### **The Governing Equation**")
st.markdown("The system tracks the rider's remaining energy balance ($W'_{bal}$) at every second using the integral form of the model:")
st.latex(r"W'_{bal}(t) = W'_{cap} - \int_{0}^{t} (P(t) - CP) dt")
st.markdown("""
**Where:**
* $W'_{bal}$: Remaining anaerobic energy balance (Joules)
* $W'_{cap}$: Total capacity of the battery (Joules)
* $P(t)$: Instantaneous Power at time $t$
* $CP$: Critical Power (Functionally equivalent to FTP)

This equation calculates the net usage of energy. When $P(t) > CP$, the integral grows, reducing the balance. When $P(t) < CP$, the system applies Skiba's exponential recovery function to restore the $W'_{bal}$.
""")

st.markdown("#### **The 'Critical Power' Duration Curve**")
st.markdown("""
Crucially, the engine uses this model to determine **Maximum Sustainable Power**. It understands that a rider's capability changes based on the duration of the effort:

* **Short Efforts (< 30 mins):** The engine allows the rider to output power **significantly above FTP**. 
    * *Why?* The $W'$ battery is large enough to sustain the high discharge rate for a short time.
    * *Example:* For a 10-minute hill climb, the target might be 110% of FTP.
    
* **Long Efforts (> 1 hour):** The engine constrains the power to **at or below FTP**.
    * *Why?* The $W'$ contribution ($Joules / Time$) becomes negligible over long durations, meaning the rider must rely on their aerobic engine (Critical Power).
    * *Example:* For a 4-hour sportive, the target might be 85-90% of FTP to ensure the battery never fully drains.
""")

st.markdown("---")

# --- 8. ARCHITECTURE ---
with st.expander("üõ†Ô∏è System Architecture & Data Processing (Click to Expand)"):
    st.markdown("### **1. Modular Architecture**")
    st.markdown("""
    The application is built on a modular, object-oriented design:
    * **Frontend (Streamlit):** Handles user interaction, file uploads, and visualization.
    * **Physics Engine (NumPy/SciPy):** A vectorised, time-stepping solver for mechanical and physiological equations.
    * **Optimiser:** A distinct module containing the Genetic Algorithm and Greedy Search logic.
    * **GPX Tool:** A dedicated ETL (Extract, Transform, Load) handler for geospatial data.
    """)

    st.markdown("### **2. The GPX Data Pipeline**")
    st.markdown("""
    Raw GPS data is rarely simulation-ready. It often contains noise, gaps, and jitter. The project implements a robust pipeline to clean this data:

    * **Geodesic Distance Calculation:** Instead of simple 2D geometry, the system uses the **Haversine Formula** to calculate precise distances over the Earth's curvature between latitude/longitude points.

    * **Adaptive Signal Smoothing:** GPS vertical error can create "phantom walls" (e.g., a 1m error over 5m creates a fake 20% gradient). 
        To fix this, the system applies **Savitzky‚ÄìGolay Filtering**. Crucially, the **window size is dynamic**‚Äîit automatically adjusts based on the data density (points per km) of the uploaded file.

    * **Intelligent Macro-Segmentation:** To make optimisation computationally feasible, the system doesn't optimise every single second. 
        Instead, it algorithmically groups the course into **Macro Segments** (e.g., "Steady Climb," "Fast Descent," "Flat Transition") based on gradient thresholds. This allows the Genetic Algorithm to assign strategic power targets to logical sections of the road.
    """)

# --- SIDEBAR FOOTER ---
st.sidebar.markdown("---")
st.sidebar.markdown(
    """
    <div style="text-align: center; color: #666666; font-size: 12px;">
        Designed & Engineered by<br>
        <strong>Dyfan Davies</strong>
    </div>
    """,
    unsafe_allow_html=True
)
