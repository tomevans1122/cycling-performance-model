#!/usr/bin/env python3# -*- coding: utf-8 -*-"""APP ORCHESTRATOR MODULE-----------------------This is the "Command Center" of the application.It coordinates the entire workflow:1. Configuration: Loads settings from config.json (Rider, Bike, Weather).2. Integration: Routes data between the GPX Tool, Physics Engine, and Optimizer.3. Visualization: Generates performance charts, pacing guides, and comparison reports."""### --- Project Module Imports --- ###import gpx_toolimport physics_engineimport optimizerimport timeimport jsonimport statisticsimport matplotlib.pyplot as pltfrom matplotlib.ticker import MultipleLocatorfrom typing import Tuple, List, Dict# _____________________________________________________________________________# --- ### --- 1. RUNTIME CONFIGURATION FLAGS --- ### ---#DEBUG_WIND_PRINTS = False # Set to True to protect against large files. Set to False for maximum precision.USE_SMART_DOWNSAMPLING = True# _____________________________________________________________________________# _____________________________________________________________________________# --- ### --- 2. VISUALIZATION & REPORTING --- ### ---def plot_segments_on_profile(gpx_track_points: List[Dict], gpx_to_opt_segment_map: List[int], course_name: str, fig_name: str = 'segmented_elevation_profile_pre_opt.png'):    """    Visualizes how the Optimizer sees the world.    It draws the elevation profile and draws red vertical lines where the segments change.    Helps you verify: "Did it correctly identify the start of the climb?"    """        # Safety Check: If the simulation crashed or produced no data, exit early.    if not gpx_track_points or not gpx_to_opt_segment_map:        print("Warning: Cannot plot segments without data.")        return        # 1. Extract Plotting Data    distances_km = [p['cumulativeDistanceM'] / 1000.0 for p in gpx_track_points] # convert to km    smoothed_elevations = [p['smoothedElevation'] for p in gpx_track_points] # uses smoothed data, not raw gpx data        # 2. Setup Plot    fig, ax1 = plt.subplots(figsize=(15, 6))    # Plot the Blue Line (Terrain)    ax1.plot(distances_km, smoothed_elevations, label='Smoothed Elevation', color='blue')     ax1.set_xlabel('Distance (km)')    ax1.set_ylabel('Elevation (m)', color='blue')    ax1.tick_params(axis='y', labelcolor='blue')    ax1.grid(True, linestyle='--', alpha=0.6)        # 3. IDENTIFY SEGMENT BOUNDARIES    # We scan the "Map" list. Anytime the Segment ID changes (e.g. from 0 to 1),    # that index marks a boundary (e.g. Start of a new hill).    segment_start_indices = [0]         for i in range(1, len(gpx_to_opt_segment_map)):        if gpx_to_opt_segment_map[i] != gpx_to_opt_segment_map[i-1]:            segment_start_indices.append(i)        # 4. DRAW RED VERTICAL LINES    # Place a marker on the graph for every detected boundary.    for index in segment_start_indices:        segment_dist_km = distances_km[index]        ax1.axvline(x=segment_dist_km, color='red', linestyle='--', alpha=0.7, linewidth=1.5)    ax1.set_title(f'Segmented Elevation Profile for {course_name} (Pre-Optimization)')    plt.tight_layout()        # Formatting X-Axis ticks (Major tick every 50km, Minor every 10km)    ax = plt.gca()     ax.xaxis.set_major_locator(MultipleLocator(50))     ax.xaxis.set_minor_locator(MultipleLocator(10))         plt.show()    #print(f"\n--- Displaying Segmented Elevation Profile Plot (File: {fig_name}) ---")def plot_performance_profile(simulation_log: List[Dict], title: str):    """    The standard "Post-Ride Analysis" chart.    Plots Power (Red) and Elevation (Green) over distance.    Used to check if the strategy makes sense (e.g. Power should go UP when Elevation goes UP).    """        # Safety Check: If the simulation crashed or produced no data, exit early.    if not simulation_log:        print(f"Warning: No log data available for {title}")        return        # 1. UNPACK DATA    # Extract columns from the list of dictionaries into simple lists for plotting    distances_km = [entry['distance'] for entry in simulation_log]    powers = [entry['power'] for entry in simulation_log]    elevations = [entry['elevation'] for entry in simulation_log]        # 2. SETUP PRIMARY AXIS (LEFT SIDE - POWER)    fig, ax1 = plt.subplots(figsize=(14, 7))    plt.title(f'{title} - Performance Analysis')    color_power = 'tab:red'    ax1.set_xlabel('Distance (km)', fontsize=12)    ax1.set_ylabel('Power (Watts)', color=color_power, fontsize=12)        # Dynamic Scaling: Set the top of the graph 10% higher than the peak power    # so the line doesn't hit the ceiling.    y1_limit_max = max(powers)+(max(powers)*0.1)    ax1.set_ylim(0, y1_limit_max)        # Plot the Power Line    ax1.plot(distances_km, powers, color=color_power, linewidth=1.5, label='Power', alpha=0.9)    ax1.tick_params(axis='y', labelcolor=color_power)    ax1.grid(True, which='major', linestyle='--', alpha=0.5)        # 3. SETUP SECONDARY AXIS (RIGHT SIDE - ELEVATION)    # We use 'twinx()' to create a second Y-axis that shares the same X-axis (Distance).    # This allows us to plot Watts (0-500) and Meters (0-2000) on the same graph.    ax2 = ax1.twinx()          color_grade = 'tab:green'    ax2.set_ylabel('Elevation (m)', color=color_grade, fontsize=12)        # Dynamic Scaling for Elevation    # We set the bottom limit lower than the lowest point so the 'mountains' float slightly and don't look squashed against the bottom.    y2_limit_min = min(elevations)-(min(elevations)*0.4)    y2_limit_max = max(elevations)+(max(elevations)*0.1)    ax2.set_ylim(0, y2_limit_max)        # 4. PLOT ELEVATION    # Use 'fill_between' to color the area under the curve (makes hills look like hills).    ax2.fill_between(distances_km, elevations, 0, color=color_grade, alpha=0.2, label='Grade Area')    ax2.plot(distances_km, elevations, color=color_grade, linewidth=1.0, linestyle=':', label='Grade')    ax2.tick_params(axis='y', labelcolor=color_grade)        fig.tight_layout()    #print(f"--- Displaying Performance Profile: {title} ---")    plt.show()def plot_comparative_performance(log_baseline: List[Dict], log_optimized: List[Dict], course_name: str):    """    The "Before vs After" comparison.    Plots the Baseline (Constant Power) vs. the Optimized Strategy on the same graph.    Crucial for seeing exactly WHERE the time was gained (e.g. "Look, the Algorithm pushed harder here").    """        if not log_baseline or not log_optimized:        print("Warning: Insufficient data for comparative plot.")        return        # 1. EXTRACT DATA SERIES    # We need to pull the raw numbers out of the dictionary logs for both riders.    dist_base = [e['distance'] for e in log_baseline]    power_base = [e['power'] for e in log_baseline]    speed_base = [e['velocity'] for e in log_baseline]        dist_opt = [e['distance'] for e in log_optimized]    power_opt = [e['power'] for e in log_optimized]    speed_opt = [e['velocity'] for e in log_optimized]        elevations = [e['elevation'] for e in log_baseline]         # 2. SETUP SUBPLOTS    # We create 2 rows, 1 column.     # 'sharex=True' means zooming in on the top graph automatically zooms the bottom one.    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(16, 9), sharex=True)    fig.suptitle(f'Comparative Pacing Strategy Analysis - {course_name}', fontsize=16)        # --- TOP PLOT: POWER STRATEGY ---    ax1.set_title('Power Output and Course Gradient')        # Baseline = Solid Red Line    ax1.plot(dist_base, power_base, label='Constant Power (Baseline)', color='tab:red', linewidth=2)    # Optimized = Dashed Blue Line (Easier to distinguish when lines overlap)    ax1.plot(dist_opt, power_opt, label='Optimised (Genetic Algorithm)', color='tab:blue', linewidth=1.5, linestyle='--')    ax1.set_ylabel('Power (Watts)', color='tab:red')        # Add 20% headroom to the Y-axis so the peak power doesn't hit the roof    y_limit_max = max(power_opt)*1.2    ax1.set_ylim(0, y_limit_max)    ax1.tick_params(axis='y', labelcolor='tab:red')    ax1.grid(True, which='both', linestyle='--', alpha=0.5)        # Secondary Y-Axis for Elevation (Context)    # We plot the hills in the background (Green Area) so you can see: "Oh, the power spiked here because there is a massive hill."    ax1_twin = ax1.twinx()    ax1_twin.fill_between(dist_base, elevations, 0, color='tab:green', alpha=0.15, label='Grade Area')    ax1_twin.set_ylabel('Elevations (m)', color='tab:green')    ax1_twin.tick_params(axis='y', labelcolor='tab:green')        # Combined Legend (Merge labels from both Y-axes into one box)    lines, labels = ax1.get_legend_handles_labels()    lines2, labels2 = ax1_twin.get_legend_handles_labels()    ax1.legend(lines + lines2, labels + labels2, loc='lower right')        # --- BOTTOM PLOT: SPEED OUTCOME ---    ax2.set_title('Speed Comparison (km/h)')        # Plot Speed Difference    ax2.plot(dist_base, speed_base, label='Constant Speed (Baseline)', color='tab:red', linewidth=2)    ax2.plot(dist_opt, speed_opt, label='Optimised Speed (Genetic Algorithm)', color='tab:blue', linewidth=1.5, linestyle='--')    ax2.set_xlabel('Distance (km)')    ax2.set_ylabel('Speed (km/h)')    ax2.set_ylim(bottom=0)    ax2.legend(loc='lower right')    ax2.grid(True, which='both', linestyle='--', alpha=0.5)        # Adjust layout to make room for the main title at the top    plt.tight_layout(rect=[0, 0.03, 1, 0.95])        filename = 'comparative_performance_profile.png'    plt.show()    #print(f"\nSaved plot to '{filename}'")def plot_pacing_strategy_guide(course_name, gpx_track_points, gpx_to_opt_segment_map, optimized_power_profile, rider_ftp, macro_metrics):    """    Generates the Race Guide.    It creates a clean, color-coded visual guide:    - Blue: Easy (Recovery)    - Yellow: Threshold    - Red: VO2 Max (Attack)    This is what the rider would actually tape to their bike stem.    """    import matplotlib.pyplot as plt    from matplotlib.lines import Line2D        # Safety Check    if not gpx_track_points or not gpx_to_opt_segment_map or not optimized_power_profile:        print("Warning: Missing data for Pacing Guide.")        return        # 1 PREPARE DATA ARRAYS    distances_km = [p['cumulativeDistanceM'] / 1000.0 for p in gpx_track_points]    elevations = [p['smoothedElevation'] for p in gpx_track_points]        # Expand the "Segment Power" list into a "Point-by-Point Power" list for plotting    target_power_curve = []    for i in range(len(gpx_track_points)):        seg_idx = gpx_to_opt_segment_map[i]        # Safety clamp to avoid index errors        seg_idx = min(seg_idx, len(optimized_power_profile) - 1)        target_power_curve.append(optimized_power_profile[seg_idx])            # 2. SETUP PLOT    fig, ax1 = plt.subplots(figsize=(16, 8))    plt.title(f'Rider Pacing Strategy Guide: {course_name}', fontsize=16, fontweight='bold')        # --- BACKGROUND: ELEVATION ---    color_elev = 'tab:gray'    ax1.set_xlabel('Distance (km)', fontsize=12)    ax1.set_ylabel('Elevation (m)', color=color_elev, fontsize=12)        # Fill the mountain shape with light gray so it sits in the background    ax1.fill_between(distances_km, elevations, 0, color=color_elev, alpha=0.2, label='Elevation')    ax1.plot(distances_km, elevations, color=color_elev, linewidth=1.0, alpha=0.5)    ax1.tick_params(axis='y', labelcolor=color_elev)    ax1.grid(True, which='major', axis='x', linestyle='--', alpha=0.5)    ax1.set_xlim(distances_km[0], distances_km[-1])        # --- FOREGROUND: POWER STRATEGY ---    ax2 = ax1.twinx()    ax2.set_ylabel('Target Power (Watts)', fontsize=12, fontweight='bold')        # Plot the main black line showing the target watts    ax2.plot(distances_km, target_power_curve, color='black', linewidth=2.5, label='Target Power')        # 3. DEFINE ZONES (Traffic Light Logic)    def get_zone_color(watts):        pct = watts / rider_ftp        if pct < 0.75: return '#3498db' # Blue (Easy/Recovery)        elif pct < 1.05: return '#f1c40f' # Yellow (Threshold/Hard)        else: return '#e74c3c' # Red (VO2 Max/Attack)            # 4. DRAW COLORED BLOCKS    # We iterate through the segments and color-code the area under the power line    segment_boundaries = [0]    for i in range(1, len(gpx_track_points)):        if gpx_to_opt_segment_map[i] != gpx_to_opt_segment_map[i-1]:            segment_boundaries.append(i)    segment_boundaries.append(len(gpx_track_points)-1)        for i in range(len(segment_boundaries)-1):        start_idx = segment_boundaries[i]        end_idx = segment_boundaries[i+1]                # Get the power target for this block        seg_id = gpx_to_opt_segment_map[start_idx]        seg_id = min(seg_id, len(optimized_power_profile)-1)        watts = optimized_power_profile[seg_id]                # Format the gradient text (e.g. "+5.2%")        grad_str = ""        if seg_id < len(macro_metrics):              grad_val = macro_metrics[seg_id]['avg_gradient']             grad_str = f"\n({grad_val:+.1f}%)"                start_dist = distances_km[start_idx]        end_dist = distances_km[end_idx]                # Pick the color (Blue/Yellow/Red)        color = get_zone_color(watts)                # Draw the colored rectangle        ax2.fill_between([start_dist, end_dist], 0, [watts, watts], color=color, alpha=0.4)                # Add Text Label (only if segment is wide enough to read)        if (end_dist - start_dist) > 0.3:              mid_dist = (start_dist + end_dist) / 2             label_text = f"{int(watts)}W{grad_str}"             ax2.text(mid_dist, watts + 10, label_text, ha='center', va='bottom', fontsize=9, fontweight='bold', color='black')        # 5. FINAL FORMATTING    max_power = max(optimized_power_profile)    ax2.set_ylim(0, max_power * 1.3)         # Draw FTP Reference Line (Dashed Gray)    ftp_label = f"FTP ({int(rider_ftp)}W)"    ax2.axhline(y=rider_ftp, color='gray', linestyle='--', linewidth=1, alpha=0.8, label=ftp_label)    ax2.text(distances_km[0], rider_ftp + 5, ftp_label, color='gray', fontsize=9, ha='left', va='bottom')        # Custom Legend    lines_1, labels_1 = ax1.get_legend_handles_labels()    lines_2, labels_2 = ax2.get_legend_handles_labels()    custom_lines = [Line2D([0], [0], color='#3498db', lw=4, alpha=0.6),                    Line2D([0], [0], color='#f1c40f', lw=4, alpha=0.6),                    Line2D([0], [0], color='#e74c3c', lw=4, alpha=0.6)]        ax1.legend(lines_1 + lines_2 + custom_lines,                ['Elevation', 'Target Power', ftp_label, 'Easy (Z1-2)', 'Threshold (Z3-4)', 'VO2 Max (Z5+)'],                loc='upper left', bbox_to_anchor=(1.08, 1), borderaxespad=0.)       plt.tight_layout()         # Save high-res version for printing    plt.savefig('rider_pacing_strategy.png', dpi=150)     print("\n--- Saved Rider Strategy Plot to 'rider_pacing_strategy.png' ---")    plt.show()def plot_convergence_history(history: List[float], title: str = "Genetic Algorithm Convergence"):    """    Shows the Algorithm's "Learning Curve".    Plots Race Time vs. Generation Number.    - If the line goes down steeply, the algorithm is learning fast.    - If it flattens out, the algorithm has found the best possible solution.    """        # Safety check: No history means no graph.    if not history:        return        # 1. PREPARE DATA    # Create X-axis: [1, 2, 3, ... N]    generations = list(range(1, len(history) + 1))        # Create Y-axis: Convert seconds to minutes (e.g., 3600s -> 60.0m) for readability.    times_min = [t / 60.0 for t in history]        # 2. SETUP PLOT    fig, ax = plt.subplots(figsize=(10, 6))        # Plot a purple line with dots at each generation marker    ax.plot(generations, times_min, marker='o', linestyle='-', color='purple', linewidth=2, markersize=5)        ax.set_title(title, fontsize=14)    ax.set_xlabel("Generation Number", fontsize=12)    ax.set_ylabel("Race Time (Minutes)", fontsize=12)    ax.grid(True, linestyle='--', alpha=0.7)        # 3. CALCULATE & SHOW IMPROVEMENT    # Compare Gen 1 (dumb luck) vs Final Gen (evolved genius).    improvement_s = history[0] - history[-1]        # Add a text box in the top-left corner (0.05, 0.95) showing the time saved.    if improvement_s > 0:        ax.text(0.05, 0.95, f"Total Improvement: {improvement_s:.1f}s",                 transform=ax.transAxes, fontsize=11, verticalalignment='top',                bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))    plt.tight_layout()    plt.show()    #print(f"--- Displaying Convergence Plot: {title} ---")    def generate_rider_report(rider_params: Dict, course_data: Dict, optimized_power_profile: List[float], optimized_time: float):    """    Prints a text-based summary table to the console.    Columns: Start km | End km | Gradient | Recommended Power | Zone    This is the raw data version of the Pacing Guide.    """        # 1. SETUP & UNPACKING    rider_ftp = rider_params['rider_ftp_watts']    macro_segment_data = course_data['macro_segment_metrics']        # Defensive Coding: Sometimes the segment data comes wrapped in a tuple (legacy artifact).    # We unwrap it here to ensure we have the raw list of dictionaries.    if isinstance(macro_segment_data, tuple):        macro_segment_metrics_list = macro_segment_data[0]    else:        macro_segment_metrics_list = macro_segment_data            # Safety Check: Ensure we don't try to read past the end of the list.      num_profile_segments = len(optimized_power_profile)    num_data_segments = len(macro_segment_metrics_list)    num_segments = min(num_profile_segments, num_data_segments)        # 2. PRINT HEADER    # Formats the total time into Hours:Minutes:Seconds    time_hour, time_min, time_sec = physics_engine.format_time_hms(optimized_time)[0:]        print("\n" + "="*80)    print(f"FINAL OPTIMISATION REPORT - Course Time: {time_hour}h {time_min}m {time_sec}s")    print(f"Rider FTP: {rider_ftp:.1f}W")    print("="*80)        # Print Table Column Headers    print("#   | Start (km) | End (km) | Dist (m) | Avg Grad | Power (W) | Zone")    print("-" * 80)        # 3. PRINT ROWS (The Segment List)    for i in range(num_segments):        power_watts = optimized_power_profile[i]        segment_details = macro_segment_metrics_list[i]                # Data Integrity Check:        # Verify that 'segment_details' is actually a dictionary with keys like 'segment_start_km'.        # If the data structure is malformed (rare bug), we catch it here instead of crashing the app.        try:            if not isinstance(segment_details, dict):                if isinstance(segment_details, (list, tuple)) and len(segment_details) > 0 and isinstance(segment_details[0], dict):                    segment_details = segment_details[0]                 else:                    raise TypeError("Segment data is neither a dictionary nor an unpackable container of a dictionary.")        except TypeError as e:            print(f"{i+1:<3} | -- ERROR --| -- ERROR -- | -- ERROR -- | -- ERROR -- | -- ERROR -- | Data type error at index {i}. SKIPPED. ({e})")            continue                # Calculate Training Zone (e.g. "Zone 4 (Threshold)")        power_zone = optimizer.get_power_zone(power_watts, rider_ftp)                 # 4. FORMATTED OUTPUT        # Use f-strings with alignment (e.g. :<10.2f) to make the columns line up perfectly.        print(            f"{i+1:<3} | "            f"{segment_details['segment_start_km']:<10.2f} | "            f"{segment_details['segment_end_km']:<8.2f} | "            f"{segment_details['actual_distance_km'] * 1000.0:<8.0f} | "            f"{segment_details['avg_gradient']:<8.1f} | "            f"{power_watts:<9.1f} | "            f"{power_zone:<30}"        )    print("="*80)# _____________________________________________________________________________# _____________________________________________________________________________# --- ### --- 3. LOGIC & ESTIMATION TOOLSdef estimate_ride_duration(rider_params: Dict, sim_params: Dict, course_data: Dict) -> float:    """    Runs a "Quick Sim" at constant FTP to guess how long the ride will take.    Why? We need this time estimate to calculate the rider's Critical Power limits.    (You can hold 300W if the ride is 10 mins, but not if it's 4 hours).    """        # Safety Check: Can't ride on a map that doesn't exist.    if not course_data.get('gpx_track_points'):        print("Warning: Cannot estimate duration without GPX track points.")        return float('inf')        # 1. CREATE A DUMMY STRATEGY    # Assume the rider holds their FTP (e.g. 250W) perfectly steady for the whole ride.    # This is not "optimal" (a real rider would vary power), but it's close enough     # to get a valid time estimate for planning purposes.    constant_power_profile = [rider_params['rider_ftp_watts']] * len(course_data['gpx_track_points'])        # 2. RUN THE SIMULATION    # We call the Physics Engine directly.    # We use underscores (_) to tell Python: "I know this function returns 4 things,     # but I only care about the first one (time). Throw the logs and stats in the trash."    estimated_time, _, _, _ = physics_engine.simulate_course(         rider_params['rider_mass'], 	rider_params['bike_mass'], 	rider_params['cda'],        rider_params['mechanical_efficiency'], 	sim_params['starting_elevation_m'],        sim_params['global_wind_speed_kmh'], 	sim_params['global_wind_direction_from_deg'],        sim_params['ambient_temperature_celsius'],        sim_params['enable_cornering_model'], 	sim_params['friction_coefficient_mu'],        sim_params['rider_skill_factor'], 	sim_params['surface_profile'],        course_data['gpx_track_points'], 	course_data['total_course_distance_m'],        constant_power_profile,        gpx_to_opt_segment_map=None, # No segmentation needed for a simple constant ride        report_progress=False, # Don't clutter the console with a progress bar for this quick check        rider_ftp=rider_params['rider_ftp_watts'],        rider_w_prime=rider_params['w_prime_capacity_j'] # Include W' for accuracy     )    return estimated_timedef adjust_power_for_duration(base_ftp: float, estimated_duration_seconds: float, w_prime_j: float) -> float:    """    The "Honesty Check".    If the user says "Target 300W" but the ride is 5 hours long, this function warns them     or adjusts the target down to a realistic number based on W' (Anaerobic Capacity).    """    # Now accepts w_prime_j as argument instead of hardcoded  value (14000)        # Safety Check: If something went wrong with the time estimate, default to a safe Endurance pace (80% FTP) to prevent a crash.    if estimated_duration_seconds == float('inf') or estimated_duration_seconds <= 0:        return base_ftp * 0.8         # 1. CALCULATE ANAEROBIC BOOST    # W' (Joules) / Time (Seconds) = Watts. Example: 15,000J / 60s = 250 Watts extra allowed. Example: 15,000J / 3600s = 4 Watts extra allowed.    anaerobic_contribution_watts = w_prime_j / estimated_duration_seconds        # 2. DETERMINE THEORETICAL MAX    # Your limit is your aerobic engine (FTP) + whatever anaerobic juice you can spread over the duration.    max_sustainable_power = base_ftp + anaerobic_contribution_watts        # 3. APPLY SAFETY MARGIN    # We target 96% of the theoretical max.     # Why? Because riding at 100% of your physiological limit usually results in "blowing up"     # (complete exhaustion) right at the line. We want a fast time, not a DNF (Did Not Finish).    target_power = max_sustainable_power * 0.96        # Reporting for the user to see the math    est_m = int(estimated_duration_seconds // 60)    est_s = int(estimated_duration_seconds % 60)    print(f"    [Honesty Check] Estimated Duration: {est_m}m {est_s}s")    print(f"    [Honesty Check] FTP: {base_ftp:.1f}W, Anaerobic Contribution: +{anaerobic_contribution_watts:.1f}W (W'={w_prime_j}J)")    print(f"    [Honesty Check] Honest Baseline Target: {target_power:.1f}W")    return target_powerdef calculate_power_from_target_time(target_time_seconds: float, rider_params: Dict, sim_params: Dict, course_data: Dict) -> float:    """    The "Reverse Solver".    User asks: "I want to finish in under 1 hour. What watts do I need?"    This function uses a Binary Search (Guess -> Check -> Adjust) to find the exact wattage required.    """        # 1. DEFINE SEARCH RANGE    # We assume the answer is somewhere between 50W (Coast) and 9999W (Rocket).    low_bound_watts = 50.0       high_bound_watts = 9999.9         # Stop when we are within 1 second of the target time.    tolerance_seconds = 1.0         sim_rider = rider_params.copy()        # 2. BINARY SEARCH LOOP    # We loop 20 times. Because Binary Search cuts the range in half every time,     # 20 steps is enough to find the answer with extreme precision even for a huge range.    for _ in range(20):                # Pick the number exactly in the middle        guess_watts = (low_bound_watts + high_bound_watts) / 2.0                # Set up a simulation where the rider holds this exact power everywhere        guess_profile = [guess_watts] * len(course_data['gpx_track_points'])                # Run the Race        sim_time, _, _, _ = physics_engine.simulate_course(             sim_rider['rider_mass'], sim_rider['bike_mass'], sim_rider['cda'],             sim_rider['mechanical_efficiency'],              sim_params['starting_elevation_m'], sim_params['global_wind_speed_kmh'],              sim_params['global_wind_direction_from_deg'], sim_params['ambient_temperature_celsius'],             sim_params['enable_cornering_model'], sim_params['friction_coefficient_mu'],             sim_params['rider_skill_factor'], sim_params['surface_profile'],             course_data['gpx_track_points'], course_data['total_course_distance_m'],             guess_profile,              gpx_to_opt_segment_map=None,               report_progress=False,             rider_ftp=guess_watts,             rider_w_prime=rider_params['w_prime_capacity_j']         )                # 3. EVALUATE RESULT        if sim_time == float('inf'):            # The rider crashed or bonked. This power is definitely too low.            low_bound_watts = guess_watts                elif abs(sim_time - target_time_seconds) < tolerance_seconds:            # BINGPOT! We found the wattage that gives the target time.            return guess_watts         elif sim_time > target_time_seconds:            # Result was TOO SLOW (Time is too big).            # We need MORE Power. Move the floor up.            low_bound_watts = guess_watts        else:            # Result was TOO FAST (Time is too small).            # We need LESS Power. Move the ceiling down.            high_bound_watts = guess_watts    return guess_watts    def get_lookup_value(value, lookup_dict, parameter_name):    """    Helper to interpret mixed inputs (String keys vs Numeric overrides).        Why this exists:    - User A wants simplicity: They select "Gravel Bike" (String).       We look this up in the dictionary to find '0.36'.    - User B is a Pro: They know their exact CdA is '0.315'.       They type that number directly. This function detects it's a number and uses it raw.    """            # CASE 1: The user provided a raw number (e.g. 0.315) in the JSON config.    # Just use it directly. This supports "Pro Mode".    if isinstance(value, (int, float)):        return float(value)        if isinstance(value, str):        clean_val = value.strip()                # CASE 2: The user provided a text option (e.g. "Gravel Bike").        # Look it up in the provided dictionary (e.g. CDA_OPTIONS).        if clean_val in lookup_dict:            # Debug print (optional): confirm the translation            # print(f"  > Interpreted '{parameter_name}': '{clean_val}' -> {lookup_dict[clean_val]}")            return float(lookup_dict[clean_val])        else:            # CASE 3: The user provided a number but wrapped in quotes (e.g. "0.5").            # Try to convert it to a float.            try:                return float(clean_val)            except ValueError:                # CASE 4: Invalid Input. Crash gracefully with a helpful error.                print(f"⚠️ Warning: '{clean_val}' is not a valid option for {parameter_name}.")                print(f"  Valid options: {list(lookup_dict.keys())}")                raise ValueError(f"Invalid {parameter_name}")        return value# --- 1. DEFINE "OFFLINE SIDEBAR" DICTIONARIES ---# These act as the "Menu" for the user. They map human-readable names # to standard physics coefficients.# Aerodynamic Drag Coefficient (CdA)# Lower is better. Dependent on bike type and body position.    CDA_OPTIONS = {        "TT Bike (Aero Bars)": 0.23, "Road Bike (Aero Bars)": 0.26,        "Road Bike (Drops)": 0.29, "Road Bike (Hoods)": 0.32, "Road Bike (Tops)": 0.38,        "Gravel Bike (Drops)": 0.33, "Gravel Bike (Hoods)": 0.36, "Gravel Bike (Tops)": 0.42,        "Mountain Bike (Tops)": 0.45    }        # Rolling Resistance Coefficient (Crr) - TIRE PART    # How much energy is lost squishing the rubber. Lower is better.    TYRE_OPTIONS = {        "Top-Tier Race (e.g. Latex/Tubeless)": 0.0030, "Mid-Range Performance (e.g. GP5000)": 0.0040,        "Training / Endurance (e.g. Gatorskin)": 0.0060, "Gravel / Cyclocross": 0.0070, "MTB Knobby": 0.0100    }        # Rolling Resistance Coefficient (Crr) - ROAD PART    # How much energy is lost vibrating the bike on rough ground. Lower is better.    # Total Crr = Tyre Crr + Surface Crr    SURFACE_OPTIONS = {        "Smooth New Tarmac": 0.0010, "Average Road (e.g. Worn Tarmac)": 0.0025,        "Rough Road / Chip Seal": 0.0050, "Light Gravel / Hardpack": 0.0070, "Heavy Gravel / Dirt": 0.0120    }        # Mechanical Drivetrain Efficiency    # Percentage of power that makes it from the pedals to the rear wheel.    MECH_OPTIONS = {        "Optimised (Waxed / Ceramic)": 0.98, "Standard (Clean & Lubed)": 0.96, "Neglected (Dirty / Old)": 0.94    }        # Wind Direction Conversion    # Maps compass points to degrees (0-360) for trigonometry.    WIND_CARDINAL = {        "N": 0, "NNE": 22.5, "NE": 45, "ENE": 67.5, "E": 90, "ESE": 112.5, "SE": 135, "SSE": 157.5,         "S": 180, "SSW": 202.5, "SW": 225, "WSW": 247.5, "W": 270, "WNW": 292.5, "NW": 315, "NNW": 337.5    }        # Tyre Friction Coefficient (Mu)    # Defines the cornering grip limit. Higher is grippier.    # Used by the safety model to slow down for sharp turns.    FRICTION_OPTIONS = {        "Dry New Tarmac (Excellent Grip)": 0.90, "Dry Worn Tarmac (Standard)": 0.80,        "Wet Tarmac": 0.60, "Gravel / Dirt": 0.55, "Ice / Snow": 0.20    }# _____________________________________________________________________________# _____________________________________________________________________________# --- ### --- 4. SIMULATION ORCHESTRATORS --- ### ---def run_selected_optimization(optimization_type: str, rider_params: Dict, sim_params: Dict, course_data: Dict, progress_bar=None) -> Tuple[float, float, List[float], List[Dict], str, List[Dict], List[float]]:     """    The Switchboard.    Takes an input string (e.g., "genetic_algorithm") and routes the data to the correct     solver in 'optimizer.py'.    It handles all the setup, execution, and data packaging for the result.    """        # 1. DATA PREP    # Unpack the massive data dictionaries into variables we can use.    gpx_track_points = course_data['gpx_track_points']    total_course_distance_m = course_data['total_course_distance_m']    rider_target_power_watts = rider_params['rider_target_power_watts']        # Initialize defaults (in case something fails)    final_time = float('inf')    avg_power = 0.0    final_power_profile_full_gpx = []    final_simulation_log = []    strategy_display_name = ""    macro_segment_metrics_output = []    avg_macro_segment_gradients = []     optimized_macro_profile = []     generation_history = []        # 2. ENSURE SEGMENTATION MAP EXISTS    # The optimizers work on "Segments" (Hills/Flats), not raw GPS points.    # We must ensure the "Map" converting GPS Points -> Segments is ready.        # Check if we already did the heavy math during the initial file load.    if 'gpx_to_opt_segment_map' in course_data:        # FAST PATH: Data exists. Just grab it.        gpx_to_opt_segment_map = course_data['gpx_to_opt_segment_map']        avg_macro_segment_gradients = course_data['avg_macro_segment_gradients']        num_dynamic_segments = course_data['num_dynamic_segments']    # SLOW PATH: Data is missing (maybe this is a fresh run or a different file).    else:        # Calculate it now. This scans the entire GPX file to find where the hills start and end.        gpx_to_opt_segment_map, avg_macro_segment_gradients, num_dynamic_segments = gpx_tool.get_macro_segment_data(            gpx_track_points, total_course_distance_m, rider_params=rider_params        )    #print("\n--- Dynamically Determined Terrain Segments ---")    #print(f"Total Segments Found: {num_dynamic_segments}")    #print("---------------------------------------------\n")       # --- BRANCH 1: THE BASELINE (CONSTANT POWER) ---    # This is the Control Group.    # We run a simulation where the rider holds their target power perfectly steady.     if optimization_type == "constant_ftp":        strategy_display_name = "Constant Power Pacing (Baseline)"                # Create a "dumb" strategy: [300W, 300W, 300W...]        constant_ftp_profile = [rider_target_power_watts] * len(gpx_track_points)                # Run the physics engine once to see how fast this strategy is.        final_time, avg_power, final_simulation_log, _ = physics_engine.simulate_course(            rider_params['rider_mass'], rider_params['bike_mass'], rider_params['cda'],            rider_params['mechanical_efficiency'],            sim_params['starting_elevation_m'], sim_params['global_wind_speed_kmh'],             sim_params['global_wind_direction_from_deg'],            sim_params['ambient_temperature_celsius'],            sim_params['enable_cornering_model'], sim_params['friction_coefficient_mu'],             sim_params['rider_skill_factor'],            sim_params['surface_profile'],            gpx_track_points, total_course_distance_m,            constant_ftp_profile,            gpx_to_opt_segment_map,            report_progress=True,            rider_ftp=rider_params['rider_ftp_watts'],            rider_w_prime=rider_params['w_prime_capacity_j']          )                # The engine needs a power value for every single GPS point (e.g. 3,500 points). We assign the constant profile we created earlier.        final_power_profile_full_gpx = constant_ftp_profile        # 2. REPORTING INPUT (Macro)        # The charts and tables (like the "Stem Sticker") expect a list of "Segment Powers" (e.g. 20 segments).        # Even though the power is constant, we must format it as a list of segments so the reporting tools downstream don't crash when they try to read "Segment 1".        optimized_macro_profile = [rider_target_power_watts] * num_dynamic_segments                 # Calculate the "Report Card" metrics for this run        macro_segment_metrics_output = gpx_tool.calculate_macro_segment_metrics(            final_simulation_log, num_dynamic_segments, optimized_macro_profile, avg_macro_segment_gradients, total_course_distance_m        )        # --- BRANCH 2: GREEDY ALGORITHM (HILL CLIMBING) ---    # This solver is faster but less smart. It randomly swaps power between segments.    elif "greedy" in optimization_type:                # Configure settings based on "Quick" vs "Moderate" selection        if optimization_type == "greedy_quick":            strategy_display_name = "Quick Optimisation (Greedy Hill Climbing)"            greedy_params = {                'optimization_attempts': optimizer.GREEDY_QUICK_ATTEMPTS,                 'power_swap_ftp_factor': optimizer.GREEDY_POWER_SWAP_FTP_FACTOR,                'no_improvement_threshold': optimizer.GREEDY_NO_IMPROVEMENT_THRESHOLD            }            initial_profile = "constant_ftp"        else:             strategy_display_name = "Moderate Optimisation (Greedy Hill Climbing)"            greedy_params = {                'optimization_attempts': optimizer.GREEDY_MODERATE_ATTEMPTS,                 'power_swap_ftp_factor': optimizer.GREEDY_POWER_SWAP_FTP_FACTOR,                'no_improvement_threshold': optimizer.GREEDY_NO_IMPROVEMENT_THRESHOLD * 5            }            initial_profile = "constant_ftp"                # CALL THE SOLVER in optimizer.py        final_time, final_power_profile_full_gpx, _, optimized_macro_profile, final_simulation_log = optimizer.optimize_pacing_greedy_hill_climbing(            rider_params, sim_params, course_data, greedy_params, num_segments=num_dynamic_segments, initial_profile_type=initial_profile        )                # VALIDATION RUN        # Run the physics engine one last time with the winning strategy to ensure we have         # the exact final time and logs (in case the optimizer used a simplified model).        if final_time != float('inf'):            _, avg_power, _, _ = physics_engine.simulate_course(                rider_params['rider_mass'], rider_params['bike_mass'], rider_params['cda'],                rider_params['mechanical_efficiency'],                sim_params['starting_elevation_m'], sim_params['global_wind_speed_kmh'],                 sim_params['global_wind_direction_from_deg'],                sim_params['ambient_temperature_celsius'],                sim_params['enable_cornering_model'], sim_params['friction_coefficient_mu'],                 sim_params['rider_skill_factor'],                sim_params['surface_profile'],                gpx_track_points, total_course_distance_m,                final_power_profile_full_gpx,                gpx_to_opt_segment_map,                report_progress=False,                rider_ftp=rider_params['rider_ftp_watts'],                rider_w_prime=rider_params['w_prime_capacity_j']            )        macro_segment_metrics_output = gpx_tool.calculate_macro_segment_metrics(            final_simulation_log, num_dynamic_segments, optimized_macro_profile, avg_macro_segment_gradients, total_course_distance_m        )        # --- BRANCH 3: GENETIC ALGORITHM (EVOLUTION) ---    # This is the "Smart" solver. It breeds strategies over generations.    elif optimization_type == "genetic_algorithm":        strategy_display_name = "Advanced Optimisation (Genetic Algorithm)"                # Pack the GA settings        ga_params = {            'population_size': sim_params.get('ga_population_size', optimizer.GA_POPULATION_SIZE),            'num_generations': sim_params.get('ga_num_generations', optimizer.GA_NUM_GENERATIONS),            'mutation_rate': sim_params.get('ga_mutation_rate', optimizer.GA_MUTATION_RATE),            'crossover_rate': sim_params.get('ga_crossover_rate', optimizer.GA_CROSSOVER_RATE),            'elitism_count': sim_params.get('ga_elitism_count', optimizer.GA_ELITISM_COUNT),            'mutation_ftp_factor': sim_params.get('ga_mutation_ftp_factor', optimizer.GA_MUTATION_FTP_FACTOR)        }                # CALL THE SOLVER in optimizer.py        # Note: We capture 'generation_history' here to plot the learning curve later.        final_time, final_power_profile_full_gpx, _, optimized_macro_profile, avg_macro_segment_gradients_ga, final_simulation_log, generation_history = optimizer.optimize_pacing_ga(            rider_params, sim_params, course_data, ga_params, num_segments=num_dynamic_segments, progress_bar=progress_bar        )        # VALIDATION RUN        # Run one final high-fidelity simulation with the evolved strategy.        if final_time != float('inf'):             _, avg_power, _, _ = physics_engine.simulate_course(                rider_params['rider_mass'], rider_params['bike_mass'], rider_params['cda'],                rider_params['mechanical_efficiency'],                sim_params['starting_elevation_m'], sim_params['global_wind_speed_kmh'],                 sim_params['global_wind_direction_from_deg'],                sim_params['ambient_temperature_celsius'],                sim_params['enable_cornering_model'], sim_params['friction_coefficient_mu'],                 sim_params['rider_skill_factor'],                sim_params['surface_profile'],                gpx_track_points, total_course_distance_m,                final_power_profile_full_gpx,                gpx_to_opt_segment_map,                report_progress=False,                rider_ftp=rider_params['rider_ftp_watts'],                rider_w_prime=rider_params['w_prime_capacity_j'] # [CHANGE 3]            )        macro_segment_metrics_output = gpx_tool.calculate_macro_segment_metrics(            final_simulation_log, num_dynamic_segments, optimized_macro_profile, avg_macro_segment_gradients_ga, total_course_distance_m        )        # Update gradients in case the GA refined the segmentation (advanced feature, rare)        avg_macro_segment_gradients = avg_macro_segment_gradients_ga         else:        print("Invalid optimisation type selected.")        return float('inf'), 0.0, [], [], "N/A", [], [], [], []      # 4. RETURN EVERYTHING    # Package all results into a single tuple for the main function to use.    return final_time, avg_power, final_power_profile_full_gpx, final_simulation_log, strategy_display_name, macro_segment_metrics_output, avg_macro_segment_gradients, optimized_macro_profile, generation_historydef run_comparative_test(num_runs: int, rider_params: Dict, sim_params: Dict, course_data: Dict, run_greedy_quick: bool, run_greedy_moderate: bool, run_genetic: bool, progress_bar=None):    """    The Benchmarker.    Runs the Baseline (Constant Power) first.    Then runs the selected advanced strategies (Greedy, Genetic).    Finally, prints a "Leaderboard" showing exactly how much faster the Algorithm was.    """        # 1. INITIALIZE SCOREBOARD    # We create empty lists to store the results of every run.    # This allows us to calculate averages if we run the test multiple times (num_runs > 1).    #print(f"\n--- Running Comparative Test for {num_runs} Run(s) ---")    all_times = {"Constant": []}          all_avg_powers = {"Constant": []}     all_avg_speeds = {"Constant": []}     all_improvements = {}                  # Map friendly names to internal function codes    strategy_map = {"Constant": "constant_ftp"}    strategies_to_run = ["Constant"]        # Placeholders for the "Winner's Data" (to plot later)    final_genetic_profile = None     final_genetic_gradients = None     final_genetic_metrics = None     final_optimized_time_seconds = None    final_constant_log = None             final_optimized_log = None        # 2. REGISTER CONTESTANTS    # Check which algorithms the user enabled in the config and add them to the race list.    if run_greedy_quick:        strategy_map["Greedy Q"] = "greedy_quick"        strategies_to_run.append("Greedy Q")        all_times["Greedy Q"] = []        all_avg_powers["Greedy Q"] = []        all_avg_speeds["Greedy Q"] = []        all_improvements["Greedy Q"] = []            if run_greedy_moderate:        strategy_map["Greedy M"] = "greedy_moderate"        strategies_to_run.append("Greedy M")        all_times["Greedy M"] = []        all_avg_powers["Greedy M"] = []        all_avg_speeds["Greedy M"] = []        all_improvements["Greedy M"] = []            if run_genetic:        final_genetic_profile = None         final_genetic_gradients = None        strategy_map["Genetic"] = "genetic_algorithm"        strategies_to_run.append("Genetic")        all_times["Genetic"] = []        all_avg_powers["Genetic"] = []        all_avg_speeds["Genetic"] = []        all_improvements["Genetic"] = []            # 3. RUN THE RACES    for run_idx in range(num_runs):        print(f"\nRun {run_idx + 1}/{num_runs}...")        current_course_data = course_data.copy()                # --- A. RUN BASELINE (The Control Group) ---        constant_ftp_time, constant_avg_power, _, constant_sim_log, _, _, _, _, _ = run_selected_optimization(            strategy_map["Constant"], rider_params, sim_params, current_course_data        )        # Print the "Time to Beat" immediately so the user has context        if constant_ftp_time != float('inf'):            c_h, c_m, c_s = physics_engine.format_time_hms(constant_ftp_time)            time_str = f"{c_h}h {c_m}m {c_s}s" if c_h > 0 else f"{c_m}m {c_s}s"            print(f"  > Baseline (Constant Power) Time: {time_str}")                    final_constant_log = constant_sim_log                # Show the Baseline chart        plot_performance_profile(constant_sim_log, "Baseline: Constant Power")                # Log Stats        all_times["Constant"].append(constant_ftp_time)        all_avg_powers["Constant"].append(constant_avg_power)        if constant_ftp_time != float('inf'):            avg_speed = physics_engine.calculate_average_speed_kmh(current_course_data['total_course_distance_m'] / 1000, constant_ftp_time)            all_avg_speeds["Constant"].append(avg_speed)        else:            all_avg_speeds["Constant"].append(0)                 # --- B. RUN CHALLENGERS (Algorithm Strategies) ---        for strategy_name in strategies_to_run:            if strategy_name == "Constant": continue # Skip baseline (already done)                        opt_type = strategy_map[strategy_name]                        # CALL THE SOLVER (Switchboard)            # We capture 'gen_history' here to see the learning curve            current_time, current_avg_power, _, current_sim_log, _, current_metrics, gradients, macro_profile, gen_history = run_selected_optimization(                opt_type, rider_params, sim_params, current_course_data, progress_bar=progress_bar if strategy_name == "Genetic" else None             )            all_times[strategy_name].append(current_time)            all_avg_powers[strategy_name].append(current_avg_power)                        # --- SPECIAL HANDLING FOR GENETIC ALGO ---            if strategy_name == "Genetic":                 # Show the "Evolved" chart                 plot_performance_profile(current_sim_log, "Optimised: Genetic Algorithm")                 # Show the "Learning Curve" (Did it get smarter over time?)                 if gen_history:                     plot_convergence_history(gen_history, "Genetic Algorithm Convergence (Diminishing Returns)")                 # Save the winner's data for the final report                 final_genetic_profile = macro_profile                 final_genetic_gradients = gradients                 final_genetic_metrics = current_metrics                  final_optimized_log = current_sim_log                 final_optimized_time_seconds = current_time                        # Log Stats & Calculate Improvement            if current_time != float('inf'):                avg_speed = physics_engine.calculate_average_speed_kmh(current_course_data['total_course_distance_m'] / 1000, current_time)                all_avg_speeds[strategy_name].append(avg_speed)                                # Compare vs Baseline (Constant Time - Algorithm Time)                improvement = constant_ftp_time - current_time                all_improvements[strategy_name].append(improvement)            else:                all_avg_speeds[strategy_name].append(0)                all_improvements[strategy_name].append(float('-inf'))        # 4. PRINT THE LEADERBOARD    print("\n--- Comparative Test Results Summary ---")    print(f"Course: {course_data['name']} ({course_data['total_course_distance_m'] / 1000:.2f} km)")    print(f"Adjusted Power Target: {rider_params['rider_target_power_watts']:.1f} Watts")        print("\nStrategy | Avg Time | Best Time | Avg Speed | Avg Power | Improvement (vs. Const)")    print("---------|----------|-----------|-----------|-----------|-------------------------")        for strategy_name in strategies_to_run:        # Filter out crashed runs (float('inf'))        times = [t for t in all_times[strategy_name] if t != float('inf')]        powers = [p for p in all_avg_powers[strategy_name] if p > 0]        speeds = [s for s in all_avg_speeds[strategy_name] if s > 0]                # Calculate Stats        avg_time = statistics.mean(times) if times else float('inf')        best_time = min(times) if times else float('inf')        avg_power_val = statistics.mean(powers) if powers else 0.0        avg_speed_val = statistics.mean(speeds) if speeds else 0.0                # Formatting Strings        avg_time_str = f"{physics_engine.format_time_hms(avg_time)[1]:02d}m {physics_engine.format_time_hms(avg_time)[2]:02d}s" if avg_time != float('inf') else "Incomplete"        best_time_str = f"{physics_engine.format_time_hms(best_time)[1]:02d}m {physics_engine.format_time_hms(best_time)[2]:02d}s" if best_time != float('inf') else "Incomplete"        avg_speed_str = f"{avg_speed_val:.2f} km/h"        avg_power_str = f"{avg_power_val:.1f} W"                # Calculate Improvement String (e.g., "+01m 30s")        improvement_str = "N/A"        if strategy_name != "Constant":            improvements = [imp for imp in all_improvements[strategy_name] if imp != float('-inf')]            if improvements:                avg_improvement = statistics.mean(improvements)                avg_imp_m = int(avg_improvement // 60)                avg_imp_s = int(abs(avg_improvement) % 60)                avg_imp_sign = "+" if avg_improvement > 0 else "-" if avg_improvement < 0 else ""                improvement_str = f"{avg_imp_sign}{avg_imp_m:02d}m {avg_imp_s:02d}s"            else:                improvement_str = "N/A"        print(f"{strategy_name:<9}| {avg_time_str:<9}| {best_time_str:<10}| {avg_speed_str:<10}| {avg_power_str:<10}| {improvement_str:<23}")        # 5. GENERATE FINAL DETAILED REPORTS (Winning Strategy Only)    if final_genetic_profile and final_genetic_gradients:        if final_optimized_time_seconds is not None:             course_data['macro_segment_metrics'] = final_genetic_metrics                          # Print the text-based Cue Sheet             generate_rider_report(                 rider_params,                 course_data,                 final_genetic_profile,                  final_optimized_time_seconds              )                          # Generate the "Stem Sticker" graphic             plot_pacing_strategy_guide(                     course_data['name'],                      course_data['gpx_track_points'],                     course_data['gpx_to_opt_segment_map'],                     final_genetic_profile,                     rider_params['rider_ftp_watts'],                     final_genetic_metrics                 )                # Print raw segment data to console for debugging        print("\n--- Final Optimised Pacing Strategy (Genetic Algorithm) ---")        print("Segment | Avg Gradient (%) | Optimised Power (W)")        print("--------|------------------|---------------------")        for i, (power, grad) in enumerate(zip(final_genetic_profile, final_genetic_gradients)):            print(f"{i+1:<8}| {grad:^16.2f} | {power:^19.1f}")        # 6. GENERATE COMPARISON CHART    # The "Red Line vs Blue Line" graph    if final_constant_log and final_optimized_log:        plot_comparative_performance(final_constant_log, final_optimized_log, course_data['name'])# _____________________________________________________________________________# _____________________________________________________________________________# --- ### --- 5. APPLICATION ENTRY POINT --- ### ---def main():    print("Script execution started...")    start_time_script = time.time()    MANUAL_SEGMENT_BOUNDARIES_KM = []        # Defaults for internal flags (can be toggled by the developer here)    RUN_GREEDY_QUICK = False    RUN_GREEDY_MODERATE = False    RUN_GENETIC_ALGORITHM = True        # 1. LOAD CONFIGURATION    # Read the 'config.json' file which acts as the control panel for the app.    print("\n--- Loading Configuration ---")    try:        with open('config.json', 'r') as f:            config = json.load(f)    except FileNotFoundError:        print("Error: 'config.json' not found.")        return            # --- 2. DEFINE "OFFLINE SIDEBAR" DICTIONARIES ---    # These act as the "Menu" for the user. They map human-readable names     # to standard physics coefficients.        # Aerodynamic Drag Coefficient (CdA)    # Lower is better. Dependent on bike type and body position.    CDA_OPTIONS = {        "TT Bike (Aero Bars)": 0.23, "Road Bike (Aero Bars)": 0.26,        "Road Bike (Drops)": 0.29, "Road Bike (Hoods)": 0.32, "Road Bike (Tops)": 0.38,        "Gravel Bike (Drops)": 0.33, "Gravel Bike (Hoods)": 0.36, "Gravel Bike (Tops)": 0.42,        "Mountain Bike (Tops)": 0.45    }        # Rolling Resistance Coefficient (Crr) - TIRE PART    # How much energy is lost squishing the rubber. Lower is better.    TYRE_OPTIONS = {        "Top-Tier Race (e.g. Latex/Tubeless)": 0.0030, "Mid-Range Performance (e.g. GP5000)": 0.0040,        "Training / Endurance (e.g. Gatorskin)": 0.0060, "Gravel / Cyclocross": 0.0070, "MTB Knobby": 0.0100    }        # Rolling Resistance Coefficient (Crr) - ROAD PART    # How much energy is lost vibrating the bike on rough ground. Lower is better.    # Total Crr = Tyre Crr + Surface Crr    SURFACE_OPTIONS = {        "Smooth New Tarmac": 0.0010, "Average Road (e.g. Worn Tarmac)": 0.0025,        "Rough Road / Chip Seal": 0.0050, "Light Gravel / Hardpack": 0.0070, "Heavy Gravel / Dirt": 0.0120    }        # Mechanical Drivetrain Efficiency    # Percentage of power that makes it from the pedals to the rear wheel.    MECH_OPTIONS = {        "Optimised (Waxed / Ceramic)": 0.98, "Standard (Clean & Lubed)": 0.96, "Neglected (Dirty / Old)": 0.94    }        # Wind Direction Conversion    # Maps compass points to degrees (0-360) for trigonometry.    WIND_CARDINAL = {        "N": 0, "NNE": 22.5, "NE": 45, "ENE": 67.5, "E": 90, "ESE": 112.5, "SE": 135, "SSE": 157.5,         "S": 180, "SSW": 202.5, "SW": 225, "WSW": 247.5, "W": 270, "WNW": 292.5, "NW": 315, "NNW": 337.5    }        # Tire Friction Coefficient (Mu)    # Defines the cornering grip limit. Higher is grippier.    # Used by the safety model to slow down for sharp turns.    FRICTION_OPTIONS = {        "Dry New Tarmac": 0.90, "Dry Worn Tarmac": 0.80,        "Wet Tarmac": 0.60, "Gravel / Dirt": 0.55, "Ice / Snow": 0.20    }    # --- 3. PARSE RIDER SETTINGS ---    # Converts the config data into a clean dictionary for the Physics Engine.    r_cfg = config['rider_settings']        # Logic: Look up the string in CDA_OPTIONS. If not found, check if it's a raw number.    base_cda = get_lookup_value(r_cfg['cda_input'], CDA_OPTIONS, "CdA")    rider_height = r_cfg.get('rider_height_cm', 178)        # Refine CdA based on height (Taller riders = more drag area)    final_cda = physics_engine.calculate_height_adjusted_cda(base_cda, rider_height)        mech_eff = get_lookup_value(r_cfg['mechanical_efficiency_input'], MECH_OPTIONS, "Mechanical Efficiency")    rider_params = {        'rider_ftp_watts': r_cfg['rider_ftp_watts'],        'rider_mass': r_cfg['rider_mass_kg'],        'bike_mass': r_cfg['bike_mass_kg'],        'cda': final_cda,         'mechanical_efficiency': mech_eff,        'w_prime_capacity_j': r_cfg.get('w_prime_capacity_j', 15000.0)     }    # --- 3. PARSE SIMULATION SETTINGS ---    # Calculates Rolling Resistance (Crr) by addinVg Tyre Crr + Surface Crr.    c_cfg = config['course_settings']    s_cfg = config['simulation_settings']        wind_dir = get_lookup_value(c_cfg['global_wind_direction_input'], WIND_CARDINAL, "Wind Direction")        # Calculate Total Rolling Resistance (Crr)    # Logic: It's the sum of the Tire's resistance and the Road's roughness.    tyre_crr = get_lookup_value(s_cfg['tyre_choice'], TYRE_OPTIONS, "Tyre Crr")    surf_crr = get_lookup_value(s_cfg['surface_choice'], SURFACE_OPTIONS, "Surface Crr")        # Check for manual override (Power User feature)    manual_crr = s_cfg.get('manual_crr_override', 0.0)    if manual_crr > 0:        final_crr = manual_crr        #print(f"  > Rolling Resistance: Using Manual Override ({final_crr})")    else:        final_crr = tyre_crr + surf_crr        #print(f"  > Rolling Resistance: {tyre_crr} (Tyre) + {surf_crr} (Surface) = {final_crr:.4f}")    friction_mu = get_lookup_value(s_cfg['friction_input'], FRICTION_OPTIONS, "Friction (Mu)")        # Package simulation parameters    sim_params = {        'global_wind_speed_kmh': c_cfg['global_wind_speed_kmh'],        'global_wind_direction_from_deg': wind_dir,        'ambient_temperature_celsius': c_cfg['ambient_temperature_celsius'],        'surface_profile': [[0.0, final_crr]],         'enable_cornering_model': s_cfg['enable_cornering_model'],        'friction_coefficient_mu': friction_mu,        'rider_skill_factor': s_cfg['rider_skill_factor'],        'starting_elevation_m': s_cfg['starting_elevation_m'],        'gpx_filename': c_cfg['gpx_filename']    }    # --- 4. OPTIMIZATION SETTINGS ---    # Loads the Genetic Algorithm settings (Mutation rate, Generations, etc.).    opt_settings = config['optimization_settings']    RUN_GREEDY_QUICK = opt_settings['run_greedy_quick']    RUN_GREEDY_MODERATE = opt_settings['run_greedy_moderate']    RUN_GENETIC_ALGORITHM = opt_settings['run_genetic_algorithm']        # Inject GA settings into the simulation parameters so the optimizer can find them later.    sim_params['ga_population_size'] = opt_settings['ga_population_size']    sim_params['ga_num_generations'] = opt_settings['ga_num_generations']    sim_params['ga_mutation_rate'] = opt_settings.get('ga_mutation_rate', 0.3)    sim_params['ga_crossover_rate'] = opt_settings.get('ga_crossover_rate', 0.8)    sim_params['ga_elitism_count'] = opt_settings.get('ga_elitism_count', 2)    sim_params['ga_mutation_ftp_factor'] = opt_settings.get('ga_mutation_ftp_factor', 0.1)        # --- 5. GPX PROCESSING ---    print(f"--- Processing GPX File: {sim_params['gpx_filename']} ---")    # 1. READ FILE    # Parse the GPX file to get raw latitude/longitude/elevation points.    # 'USE_SMART_DOWNSAMPLING' reduces huge files (e.g. 10,000 points) to manageble sizes     # without losing the shape of the hills.    gpx_result_dict = gpx_tool.parse_gpx_file(    sim_params['gpx_filename'],     auto_downsample=USE_SMART_DOWNSAMPLING)    gpx_track_points = gpx_result_dict['trackPoints']        if gpx_track_points:        # Override the config's starting elevation with the actual data from the file.        real_elevation = gpx_track_points[0]['ele']        sim_params['starting_elevation_m'] = real_elevation        print(f"  > Overriding Starting Elevation from GPX: {real_elevation:.1f} m")        # 2. ENRICH DATA    # [Performance Tweak] Pre-calculate the Rolling Resistance (Crr) for every single point now.    # This prevents the physics engine from doing the same math 3,000 times inside the loop.    gpx_tool.enrich_track_with_surface_profile(gpx_track_points, sim_params['surface_profile'])        total_course_distance_m = gpx_result_dict['totalDistanceKm'] * 1000    plot_data = gpx_result_dict['plot_data']        # Package the course data for the optimizer    course_data = {        'name': gpx_result_dict['name'],        'gpx_track_points': gpx_track_points,        'total_course_distance_m': total_course_distance_m,        'total_elevation_gain_m': gpx_tool.calculate_total_ascent(gpx_track_points)    }        # 3. SEGMENTATION (THE "TERRAIN SCAN")    # Scan the file to group points into "Hills" and "Flats".    # This is crucial for the optimizer, which thinks in terms of "Segments" (e.g. "Push on the climb"),    # rather than individual GPS dots.    # print("\n--- Calculating Course Segmentation ---")    start_time_segmentation = time.time()    gpx_to_opt_segment_map, avg_macro_segment_gradients, num_dynamic_segments = gpx_tool.get_macro_segment_data(        gpx_track_points,        total_course_distance_m,        rider_params=rider_params,        manual_boundaries_km=MANUAL_SEGMENT_BOUNDARIES_KM     )    end_time_segmentation = time.time()    #print(f"*** Segmentation Calculation Time: {end_time_segmentation - start_time_segmentation:.2f} seconds ***")        # Save the segmentation map so we don't have to recalculate it later.    course_data['gpx_to_opt_segment_map'] = gpx_to_opt_segment_map    course_data['avg_macro_segment_gradients'] = avg_macro_segment_gradients    course_data['num_dynamic_segments'] = num_dynamic_segments        # Debug Plot: Show the user where we think the hills are.    plot_segments_on_profile(gpx_track_points, gpx_to_opt_segment_map, course_data['name'])        # --- 6. AUTO-CALCULATE POWER SWITCH ---    # Checks if the user wants the "Smart Target" feature.    # If YES: Runs estimate_ride_duration -> adjust_power_for_duration to find the optimal target.    # If NO: Uses the manual FTP value from the config.    base_rider_ftp_watts = rider_params['rider_ftp_watts']        if opt_settings.get('auto_calculate_power_target', False):        print("\n--- [SWITCH ON] Auto-Calculate Power Target ---")                # Step 1: Guess the duration (using base FTP).        estimated_time_s = estimate_ride_duration(rider_params, sim_params, course_data)                if estimated_time_s != float('inf'):                        # Step 2: Adjust target based on Critical Power (W').            # If it's short, target > FTP. If long, target < FTP.            adjusted_target_power = adjust_power_for_duration(                base_rider_ftp_watts, estimated_time_s, rider_params['w_prime_capacity_j']            )            rider_params['rider_target_power_watts'] = adjusted_target_power            print(f"  > Adjusted Target: {adjusted_target_power:.1f} W")        else:            print("  > Could not estimate duration. Reverting to Base FTP.")            rider_params['rider_target_power_watts'] = base_rider_ftp_watts    else:        print("\n--- [SWITCH OFF] Using Manual Power Target ---")        print(f"  > Using fixed FTP/Target from JSON: {base_rider_ftp_watts:.1f} W")        rider_params['rider_target_power_watts'] = base_rider_ftp_watts    print("-------------------------------------------------")        # --- 7. RUN THE RACE ---    total_mass = rider_params['rider_mass'] + rider_params['bike_mass']        # Print the "Race Card" summary before starting.    print("\n--- Cycling Time Trial Prediction (Dynamic Simulation) ---")    print(f"Course Name: {course_data['name']}")    print(f"Total Smoothed Elevation Gain: {course_data['total_elevation_gain_m']:.1f} m")    print(f"Adjusted Rider Power Target: {rider_params['rider_target_power_watts']:.1f} Watts")    print(f"Rider Mass: {rider_params['rider_mass']} kg, Bike Mass: {rider_params['bike_mass']} kg (Total: {total_mass} kg)")    print(f"Starting Elevation: {sim_params['starting_elevation_m']:.0f} meters")    print(f"Global Wind: {sim_params['global_wind_speed_kmh']:.1f} km/h from {sim_params['global_wind_direction_from_deg']:.1f}°")        # START THE MAIN ALGORITHM    NUM_COMPARATIVE_RUNS = 1     run_comparative_test(        NUM_COMPARATIVE_RUNS,        rider_params,        sim_params,        course_data,        run_greedy_quick=RUN_GREEDY_QUICK,        run_greedy_moderate=RUN_GREEDY_MODERATE,        run_genetic=RUN_GENETIC_ALGORITHM    )        # --- 8. BONUS: REVERSE SOLVER TEST ---    # This demonstrates the web app feature: "Time -> Power Calculator".    # Instead of asking "How fast will I go at 300W?", we ask "What watts do I need to break 60 minutes?"    print("\n--- Testing Web Feature: Time -> Power Calculator ---")        # 1. Get a baseline time    best_time_seconds = estimate_ride_duration(rider_params, sim_params, course_data)       # 2. Set a goal: "I want to be 30 seconds faster than that."    target_time_s = best_time_seconds - 30.0     target_min = int(target_time_s // 60)    target_sec = int(target_time_s % 60)    print(f"Goal: Finish in {target_min}m {target_sec}s (30s faster than constant power)")        # 3. Solve for Watts    required_watts = calculate_power_from_target_time(target_time_s, rider_params, sim_params, course_data)    print(f"Solver Result: To hit {target_min}m {target_sec}s, you need to hold {required_watts:.1f} Watts.")    print("-------------------------------------------------")        # Execution Timer (Performance monitoring)    end_time_script = time.time()    duration = end_time_script - start_time_script    minutes = int(duration // 60)    seconds = int(duration % 60)    print(f"\nTotal script execution time: {minutes}m {seconds}s")if __name__ == "__main__":    main()                